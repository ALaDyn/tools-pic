/*******************************************************************************
This file is part of tools_pic.

tools_pic is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
tools-pic is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with tools-pic.  If not, see <http://www.gnu.org/licenses/>.

*******************************************************************************/

#include<mpi.h>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<string>
#include<sstream>
#include<istream>
#include<fstream>
#include<iomanip>
#include<iostream>
#include<cstring>
#include<vector>

bool flag_swap=false;

bool flag_1D=false;
bool flag_2D=false;
bool flag_3D=false;

bool flag_first=false;
int what_first;

bool flag_second=false;
int what_second;

bool flag_third=false;
int what_third;

bool flag_first_min=false;
double first_min;
bool flag_first_max=false;
double first_max;
bool flag_first_bins=false;
long long first_bins;

bool flag_second_min=false;
double second_min;
bool flag_second_max=false;
double second_max;
bool flag_second_bins=false;
long long second_bins;


bool flag_third_min=false;
double third_min;
bool flag_third_max=false;
double third_max;
bool flag_third_bins=false;
long long third_bins;

bool flag_with_filters=false;
struct filter{
  int on_what;
  bool is_there_minval;
  bool is_there_maxval;
  double minval;
  double maxval;
};
std::vector<filter> filterList;

bool flag_inputfile=false;
std::string inputfileName;

bool flag_outputfile=false;
std::string outputfileName;

bool flag_mass=false;
double mass;

bool flag_vtk=false;

#define NUM_COMPONENTS 7
#define NUM_QUANTITIES 9
#define VERY_BIG_POS_NUM +1.0e30
#define VERY_BIG_NEG_NUM -1.0e30
std::string quantitiesNames[NUM_QUANTITIES] = {"X","Y","Z","Px","Py","Pz","Ptot","Ktot", "theta2D"};
bool filter_flags[NUM_QUANTITIES] = {false,false,false,false,false,false,false,false};
double min_filter[NUM_QUANTITIES] = {0,0,0,0,0,0,0,0};
double max_filter[NUM_QUANTITIES] = {0,0,0,0,0,0,0,0};

struct parallelData{
  int myRank;
  int nProc;
  MPI_Comm comm;
};

void parseArgs(int narg, char **args, parallelData pdata);
void checkFlagsConsistence(parallelData pdata);
int howManyFilesExist(std::string strippedFileName);
long long int howLongIsInputFile(std::string fileName);
void message(parallelData pdata, std::string msg);
void errorMessage(parallelData pdata, std::string msg);
std::string composeFileName(std::string strippedFileName, int fileId);
long long int calcParticlesToRead(parallelData pdata, int particleTotalNumber);

void swap_endian_float_array(float* in_f, int n);

void read_next_extremes(MPI_File myFile,long long numreader);
void read_next_plot(MPI_File myFile, long long numreader, double* plotData);

const int readLength = 1000000;

double mincomponents[NUM_QUANTITIES];
double maxcomponents[NUM_QUANTITIES];


int main(int narg, char **args)
{ 
  MPI_Init(&narg, &args);
  parallelData world;
  MPI_Comm_rank(MPI_COMM_WORLD,&world.myRank);
  MPI_Comm_size(MPI_COMM_WORLD,&world.nProc);
  world.comm = MPI_COMM_WORLD;

  long long fileLengthInBytes, particleTotalNumber;
  parseArgs(narg,args,world);
  checkFlagsConsistence(world);

  int numberOfFiles = howManyFilesExist(inputfileName);
  if(numberOfFiles <= 0)
    errorMessage(world, "Input file not found");

  if(numberOfFiles>world.nProc){
    std::stringstream ss;
    ss << "Too many files! " << "( " << numberOfFiles << " > " << world.nProc << " )";
    errorMessage(world, ss.str());
  }

  int fileId = world.myRank%numberOfFiles;

  parallelData fileGroup;
  MPI_Comm_split(world.comm, fileId, 0, &fileGroup.comm);
  MPI_Comm_rank(fileGroup.comm,&fileGroup.myRank);
  MPI_Comm_size(fileGroup.comm,&fileGroup.nProc);

  std::string fileName = composeFileName(inputfileName,fileId);

  fileLengthInBytes = howLongIsInputFile(fileName);
  if(fileLengthInBytes < 0){
    errorMessage(fileGroup, fileName + " not found!");
  }
  particleTotalNumber = fileLengthInBytes/(sizeof(float)*NUM_COMPONENTS);

  std::stringstream ss;
  ss << "There are: " << particleTotalNumber <<" particles in file "<<fileId<< ".";
  message(fileGroup, ss.str());

  MPI_File theFile;
  char * S = new char[fileName.length() + 1];
  std::strcpy(S,fileName.c_str());

  long long myparticlesToRead = calcParticlesToRead(fileGroup, particleTotalNumber);

  long long *particlesToRead = new long long[fileGroup.nProc];
  particlesToRead[fileGroup.myRank] = myparticlesToRead;
  MPI_Allgather(MPI_IN_PLACE, 1, MPI_LONG_LONG_INT, particlesToRead, 1, MPI_LONG_LONG_INT, fileGroup.comm);
  MPI_Offset disp = 0;
  int readings = myparticlesToRead/readLength;
  int reminder = myparticlesToRead%readLength;
  int maxReadings = 0;
  for (int i = 0; i < fileGroup.nProc; i++){
    if (i < fileGroup.myRank)
      disp+=particlesToRead[i]*NUM_COMPONENTS*sizeof(float);

    int ireadings =particlesToRead[i]/readLength;
    if(ireadings>maxReadings)
      maxReadings=ireadings;

  }
  delete[] particlesToRead;


  if(
     !(
       (flag_1D && flag_first_min && flag_first_max)||
       (flag_2D && flag_first_min && flag_first_max && flag_second_min && flag_second_max)||
       (flag_3D && flag_first_min && flag_first_max && flag_second_min && flag_second_max && flag_third_min && flag_third_max)
       )
     ){
    message(world, "A preliminary reading is needed to find unspecified plot extremes");

    MPI_File_open(fileGroup.comm, S, MPI_MODE_RDONLY, MPI_INFO_NULL , &theFile);
    MPI_File_set_view(theFile, disp, MPI_FLOAT, MPI_FLOAT, (char *) "native", MPI_INFO_NULL);

    for (int i = 0; i < NUM_QUANTITIES; i++){
      mincomponents[i]=VERY_BIG_POS_NUM;
      maxcomponents[i]=VERY_BIG_NEG_NUM;
    }

    for (int i = 0; i < readings; i++){
      read_next_extremes(theFile,readLength);
    }
    read_next_extremes(theFile,reminder);
    for (int i = 0;i < maxReadings-readings; i++){
      read_next_extremes(theFile, 0);
    }

    MPI_Allreduce(MPI_IN_PLACE, mincomponents, NUM_QUANTITIES, MPI_DOUBLE, MPI_MIN, world.comm);
    MPI_Allreduce(MPI_IN_PLACE, maxcomponents, NUM_QUANTITIES, MPI_DOUBLE, MPI_MAX, world.comm);

    MPI_File_close(&theFile);

    std::stringstream ss;

    ss << std::endl;

    ss << "End of the preliminary reading" << std::endl;
    ss <<"NEW LIMITS:"<<std::endl;

    if (flag_1D || flag_2D || flag_3D){
      if(!flag_first_min)first_min=mincomponents[what_first];
      if(!flag_first_max)first_max=maxcomponents[what_first];
      ss << "First quantity plot limits: " << first_min << " -- " << first_max << std::endl;
    }
    if (flag_2D || flag_3D){
      if(!flag_second_min)second_min=mincomponents[what_second];
      if(!flag_second_max)second_max=maxcomponents[what_second];
      ss << "Second quantity plot limits: " << second_min << " -- " << second_max << std::endl;
    }
    if (flag_3D){
      if(!flag_third_min)third_min=mincomponents[what_third];
      if(!flag_third_max)third_max=maxcomponents[what_third];
      ss << "Third quantity plot limits: " << third_min << " -- " << third_max << std::endl;
    }
    ss << "Plot limits will be increased by a 5%" << std::endl;

    message(world, ss.str());

    first_min-=0.05*first_min;
    first_max+=0.05*first_max;

    second_min-=0.05*second_min;
    second_max+=0.05*second_max;

    third_min-=0.05*third_min;
    third_max+=0.05*third_max;


  }

  if(first_min>=first_max){
    errorMessage(world, "First quantity limits error");
  }
  if((flag_2D||flag_3D)&&(second_min>=second_max)){
    errorMessage(world, "Second quantity limits error");
  }
  if(flag_3D&&(third_min>=third_max)){
    errorMessage(world, "Third quantity limits error");
  }

  message(world, "Preparing plot data...");

  if(flag_1D){
    second_bins = 1;
    third_bins = 1;
  }
  else if(flag_2D){
    third_bins = 1;
  }

  double* plotData = new double[first_bins*second_bins*third_bins];

  for( long long i = 0; i < first_bins; i++)
    for(long long j = 0; j < second_bins; j++)
      for(long long k = 0; k < third_bins; k++)
      {
        plotData[i+j*first_bins+k*first_bins*second_bins] = 0.0;
      }

  MPI_File_open(fileGroup.comm, S, MPI_MODE_RDONLY, MPI_INFO_NULL , &theFile);
  MPI_File_set_view(theFile, disp, MPI_FLOAT, MPI_FLOAT, (char *) "native", MPI_INFO_NULL);

  for (int i = 0; i < readings; i++){
    read_next_plot(theFile,readLength,plotData);
  }
  read_next_plot(theFile, reminder,plotData);
  for (int i = 0; i < maxReadings-readings; i++){
    read_next_plot(theFile,readLength,plotData);
  }

  MPI_Allreduce(MPI_IN_PLACE, plotData, first_bins*second_bins*third_bins, MPI_DOUBLE, MPI_SUM, world.comm);

  MPI_File_close(&theFile);
  ss.str(std::string());
  ss << std::endl;
  ss<<"Writing plot data on disk..."<<std::endl;
  message(world,ss.str());

  if(world.myRank == 0){

    std::ofstream outfile;

    if(flag_1D){
      outfile.open(outputfileName.c_str());

      long long j = 0;
      long long k = 0;
      for (long long i = 0; i < first_bins; i++){
        double fcoord = (i + i + 1)*0.5/first_bins*(first_max-first_min)+first_min;
        outfile << fcoord << " " << plotData[i+j*first_bins+k*first_bins*second_bins] << std::endl;
      }
      outfile.close();
    }
    else if(flag_2D){
      outfile.open(outputfileName.c_str());

      long long k = 0;
      for (long long j = 0; j < second_bins; j++)
        for (long long i = 0; i < first_bins; i++){
          double fcoord = (i + i + 1)*0.5/first_bins*(first_max-first_min)+first_min;
          double scoord = (j + j + 1)*0.5/second_bins*(second_max-second_min)+second_min;
          outfile << fcoord << " " << scoord << " "<< plotData[i+j*first_bins+k*first_bins*second_bins] << std::endl;
        }
      outfile.close();
    }
    else if(flag_3D)
    {
      if(!flag_vtk)
      {
        outfile.open(outputfileName.c_str());

        for (long long k = 0; k < third_bins; k++)
          for (long long j = 0; j < second_bins; j++)
            for (long long i = 0; i < first_bins; i++){
              double fcoord = (i + i + 1)*0.5/first_bins*(first_max-first_min)+first_min;
              double scoord = (j + j + 1)*0.5/second_bins*(second_max-second_min)+second_min;
              double tcoord = (k + k + 1)*0.5/third_bins*(third_max-third_min)+third_min;
              outfile << fcoord << " " << scoord << " "<< tcoord << " " << plotData[i+j*first_bins+k*first_bins*second_bins] << std::endl;
            }
        outfile.close();
      }
      else{
        FILE *clean_fields=fopen(outputfileName.c_str(),"wb");

        fprintf(clean_fields, "# vtk DataFile Version 2.0\n");
        fprintf(clean_fields, "titolo mio\n");
        fprintf(clean_fields, "BINARY\n");
        fprintf(clean_fields, "DATASET STRUCTURED_POINTS\n");
        fprintf(clean_fields, "DIMENSIONS %lld %lld %lld\n", first_bins,second_bins,third_bins  );
        fprintf(clean_fields, "ORIGIN %f %f %f\n", first_min, second_min, third_min);
        double dx  = (first_max-first_min)/first_bins;
        double dy = (second_max-second_min)/second_bins;
        double dz  = (third_max-third_min)/third_bins;

        fprintf(clean_fields, "SPACING %f %f %f\n", dx, dy, dz);
        fprintf(clean_fields, "POINT_DATA %lld\n", first_bins*second_bins*third_bins);
        fprintf(clean_fields, "SCALARS ciccio double 1\n" );
        fprintf(clean_fields, "LOOKUP_TABLE default\n");
        fwrite((void*)plotData, sizeof(double), first_bins*second_bins*third_bins, clean_fields);
        fclose(clean_fields);
      }
    }

  }


  delete[] plotData;
  MPI_Finalize();
  return 0;
}



void parseArgs(int nNumberofArgs, char* pszArgs[], parallelData pdata){
  if(nNumberofArgs<2){
    std::stringstream ss;
    ss << "USAGE: " << std::endl;
    ss << "\ttitan -i inputFile -o outputFile -1D (or) -2D (or) -3D" << std::endl;
    ss <<"\t-first $FIRST_COMP -second $SECOND_COMP -third $THIRD_COMP" << std::endl;
    for(int c=0; c < NUM_QUANTITIES; c ++) {
      ss << c << " = "  << quantitiesNames[c].c_str() << std::endl;
    }
    ss << std::endl << "\t-1min $FIRST_COMP_MIN -1max $FIRST_COMP_MAX" << std::endl;
    ss << "\t -1nbin $FIRST_COMP_NBIN" << std::endl;
    ss << "\t-filter $FILTER_COMP:$MIN:$MAX" << std::endl;
    message(pdata, ss.str());
  }
  for (int i = 1; i < nNumberofArgs; i++){
    if (std::string(pszArgs[i]) == "-swap"){
      flag_swap=true;
    }

    if (std::string(pszArgs[i]) == "-1D"){
      flag_1D=true;
    }

    if (std::string(pszArgs[i]) == "-2D"){
      flag_2D=true;
    }

    if (std::string(pszArgs[i]) == "-3D"){
      flag_3D=true;
    }

    if (std::string(pszArgs[i]) == "-first"){
      flag_first=true;
      if (i + 1 != nNumberofArgs){
        what_first = atoi(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "FIRST quantity not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-second"){
      flag_second=true;
      if (i + 1 != nNumberofArgs){
        what_second = atoi(pszArgs[i+1]);
        i++;
      }
      else{
        errorMessage(pdata, "SECOND quantity not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-third"){
      flag_third=true;
      if (i + 1 != nNumberofArgs){
        what_third = atoi(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "THIRD quantity not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-1min"){
      flag_first_min=true;
      if (i + 1 != nNumberofArgs){
        first_min = atof(pszArgs[i+1]);
        i++;
      }
      else{       
        errorMessage(pdata, "FIRST min not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-2min"){
      flag_second_min=true;
      if (i + 1 != nNumberofArgs){
        second_min = atof(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "SECOND min not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-3min"){
      flag_third_min=true;
      if (i + 1 != nNumberofArgs){
        third_min = atof(pszArgs[i+1]);
        i++;
      }
      else{        
         errorMessage(pdata, "THIRD min not provided!");
      }
    }



    if (std::string(pszArgs[i]) == "-1max"){
      flag_first_max=true;
      if (i + 1 != nNumberofArgs){
        first_max = atof(pszArgs[i+1]);
        i++;
      }
      else{       
        errorMessage(pdata, "FIRST max not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-2max"){
      flag_second_max=true;
      if (i + 1 != nNumberofArgs){
        second_max = atof(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "SECOND max not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-3max"){
      flag_third_max=true;
      if (i + 1 != nNumberofArgs){
        third_max = atof(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "THIRD max not provided!");
      }
    }


    if (std::string(pszArgs[i]) == "-1nbin"){
      flag_first_bins=true;
      if (i + 1 != nNumberofArgs){
        first_bins = atoi(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "FIRST bins not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-2nbin"){
      flag_second_bins=true;
      if (i + 1 != nNumberofArgs){
        second_bins = atoi(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "SECOND bins not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-3nbin"){
      flag_third_bins=true;
      if (i + 1 != nNumberofArgs){
        third_bins = atoi(pszArgs[i+1]);
        i++;
      }
      else{        
        errorMessage(pdata, "THIRD bins not provided!");
      }
    }


    if (std::string(pszArgs[i]) == "-filter"){
      flag_with_filters=true;
      if (i + 1 != nNumberofArgs){
        filter new_filter;

        char split_char = ':';
        std::istringstream split(std::string(pszArgs[i+1]));
        std::vector<std::string> token;
        for (std::string each; std::getline(split, each, split_char); token.push_back(each));

        if(token.size()!=3){          
          errorMessage(pdata, "wrong FILTER provided!");
        }


        new_filter.on_what = atoi(token[0].c_str());


        if (token[1]=="*"){
          new_filter.is_there_minval=false;
        }
        else{
          new_filter.is_there_minval=true;
          new_filter.minval=atof(token[1].c_str());
        }



        if (token[2]=="*"){
          new_filter.is_there_maxval=false;
        }
        else{
          new_filter.is_there_maxval=true;
          new_filter.maxval=atof(token[2].c_str());
        }


        filterList.push_back(new_filter);

        i++;
      }
      else{
        errorMessage(pdata, "FILTER not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-i"){
      flag_inputfile=true;
      if (i + 1 != nNumberofArgs){
        inputfileName = std::string(pszArgs[i+1]);
        i++;
      }
      else{
        errorMessage(pdata, "INPUTFILE not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-o"){
      flag_outputfile=true;
      if (i + 1 != nNumberofArgs){
        outputfileName = std::string(pszArgs[i+1]);
        i++;
      }
      else{
        errorMessage(pdata, "OUTPUTFILE not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-m"){
      flag_mass=true;
      if (i + 1 != nNumberofArgs){
        mass = atof(pszArgs[i+1]);
        i++;
      }
      else{
        errorMessage(pdata, "MASS not provided!");
      }
    }

    if (std::string(pszArgs[i]) == "-vtk"){
      flag_vtk=true;
    }
  }
}

void checkFlagsConsistence(parallelData pdata){
  std::stringstream ss;
  if(flag_swap){
    ss << "Endianess swap: ON" << std::endl;
  }
  else{
    ss << "Endianess swap: OFF" << std::endl;
  }

  if(flag_1D){
    if(flag_2D || flag_3D){
      errorMessage(pdata, "Only one plot dimension can be chosen!");
    }
    ss << "Plot type: 1D" << std::endl;
  }
  else if(flag_2D){
    if(flag_3D){
      errorMessage(pdata, "Only one plot dimension can be chosen!");
    }
    ss << "Plot type: 2D" << std::endl;
  }
  else if(flag_3D){
    ss << "Plot type: 3D" << std::endl;
  }

  if(flag_1D){
    if(flag_first){

      if(what_first < 0 || what_first >= NUM_QUANTITIES){
        errorMessage(pdata, "Wrong FIRST quantity setting.");
      }

      ss << "First quantity: " << quantitiesNames[what_first] << std::endl;
      ss << "Second quantity: --" << std::endl;
      ss << "Third quantity: --" << std::endl;

      ss << "First quantity plot limits: ";
      if(flag_first_min){
        ss << first_min;
      }
      else{
        ss << "NO LIMIT";
      }
      ss << " -- ";
      if(flag_first_max){
        ss << first_max;
      }
      else{
        ss << "NO LIMIT";
      }
      ss<<std::endl;
      if(!flag_first_bins)
        first_bins=200;
      ss << "First quantity bins: " << first_bins;
      if(!flag_first_bins)
        ss << " (DEFAULT) ";
      ss<<std::endl;

      ss << "Second quantity plot limits: --" << std::endl;
      ss << "Second quantity bins: --" << std::endl;

      ss << "Third quantity plot limits: --" << std::endl;
      ss << "Third quantity bins: --" << std::endl;

    }
    else{
      errorMessage(pdata, "FIRST quantity should be provided for 1D plot!");
    }
  }

  if(flag_2D){
    if(flag_first && flag_second){
      if(what_first < 0 || what_first >= NUM_QUANTITIES){
        errorMessage(pdata, "Wrong FIRST quantity setting.");
      }
      if(what_second < 0 || what_second >= NUM_QUANTITIES){
        errorMessage(pdata, "Wrong SECOND quantity setting.");
      }

      ss << "First quantity: " << quantitiesNames[what_first] << std::endl;
      ss << "Second quantity: " << quantitiesNames[what_second] << std::endl;
      ss << "Third quantity: --" << std::endl;

      ss << "First quantity plot limits: ";
      if(flag_first_min){
        ss << first_min;
      }
      else{
        ss << "NO LIMIT";
      }
      ss << " -- ";
      if(flag_first_max){
        ss << first_max;
      }
      else{
        ss << "NO LIMIT";
      }
      ss<<std::endl;
      if(!flag_first_bins)
        first_bins=200;
      ss << "First quantity bins: " << first_bins;
      if(!flag_first_bins)
        ss << " (DEFAULT) ";
      ss<<std::endl;

      ss << "Second quantity plot limits: ";
      if(flag_second_min){
        ss << second_min;
      }
      else{
        ss << "NO LIMIT";
      }
      ss << " -- ";
      if(flag_second_max){
        ss << second_max;
      }
      else{
        ss << "NO LIMIT";
      }
      ss<<std::endl;
      if(!flag_second_bins)
        second_bins=200;
      ss << "Second quantity bins: " << second_bins;
      if(!flag_second_bins)
        ss << " (DEFAULT) ";
      ss<<std::endl;

      ss << "Third quantity plot limits: --" << std::endl;
      ss << "Third quantity bins: --" << std::endl;
    }
    else{
      errorMessage(pdata, "FIRST and SECOND quantities should be provided for 2D plot!");
    }
  }

  if(flag_3D){
    if(flag_first && flag_second && flag_third){

      if(what_first < 0 || what_first >= NUM_QUANTITIES){
        errorMessage(pdata, "Wrong FIRST quantity setting.");
      }
      if(what_second < 0 || what_second >= NUM_QUANTITIES){
        errorMessage(pdata, "Wrong SECOND quantity setting.");
      }
      if(what_third < 0 || what_third>= NUM_QUANTITIES){        
        errorMessage(pdata, "Wrong THIRD quantity setting.");
      }

      ss << "First quantity: " << quantitiesNames[what_first] << std::endl;
      ss << "Second quantity: " << quantitiesNames[what_second] << std::endl;
      ss << "Third quantity: " << quantitiesNames[what_third] << std::endl;

      ss << "First quantity plot limits: ";
      if(flag_first_min){
        ss << first_min;
      }
      else{
        ss << "NO LIMIT";
      }
      ss << " -- ";
      if(flag_first_max){
        ss << first_max;
      }
      else{
        ss << "NO LIMIT";
      }
      ss<<std::endl;
      if(!flag_first_bins)
        first_bins=200;
      ss << "First quantity bins: " << first_bins;
      if(!flag_first_bins)
        ss << " (DEFAULT) ";
      ss<<std::endl;

      ss << "Second quantity plot limits: ";
      if(flag_second_min){
        ss << second_min;
      }
      else{
        ss << "NO LIMIT";
      }
      ss << " -- ";
      if(flag_second_max){
        ss << second_max;
      }
      else{
        ss << "NO LIMIT";
      }
      ss<<std::endl;
      if(!flag_second_bins)
        second_bins=200;
      ss << "Second quantity bins: " << second_bins;
      if(!flag_second_bins)
        ss << " (DEFAULT) ";
      ss<<std::endl;

      ss << "Third quantity plot limits: ";
      if(flag_third_min){
        ss << third_min;
      }
      else{
        ss << "NO LIMIT";
      }
      ss << " -- ";
      if(flag_third_max){
        ss << third_max;
      }
      else{
        ss << "NO LIMIT";
      }
      ss<<std::endl;
      if(!flag_third_bins)
        third_bins=200;
      ss << "Third quantity bins: " << third_bins;
      if(!flag_third_bins)
        ss << " (DEFAULT) ";
      ss<<std::endl;
    }
    else{
      errorMessage(pdata, "FIRST, SECOND and THIRD quantities should be provided for 3D plot!");
    }
  }

  if(flag_inputfile && inputfileName!=""){
    ss << "Input file: " << inputfileName << std::endl;
  }
  else{
    std::cout << "Input file not provided!" << std::endl;
    exit(1);
  }

  if(flag_outputfile && outputfileName!=""){
    ss << "Output file: " << outputfileName << std::endl;
  }
  else{
    std::cout << "Output file not provided!" << std::endl;
    exit(1);
  }

  if(flag_mass){
    ss << "Particle mass: " << mass << std::endl;
  }
  else{
    mass = 1.0;
    ss << "Particle mass: " << mass << " (DEFAULT)" << std::endl;
  }

  if(flag_with_filters){
    for (std::vector<filter>::iterator it = filterList.begin() ; it != filterList.end(); ++it){
      filter fil = *it;
      if(filter_flags[fil.on_what]){

        std::cout << "Error! Multiple filter !" << std::endl;
        exit(1);
      }
      filter_flags[fil.on_what]=true;

      max_filter[fil.on_what]=(fil.is_there_maxval)?(fil.maxval):(VERY_BIG_POS_NUM);
      min_filter[fil.on_what]=(fil.is_there_minval)?(fil.minval):(VERY_BIG_NEG_NUM);

      if(max_filter[fil.on_what]<min_filter[fil.on_what]){
        errorMessage(pdata, "Error in filter definition!");
      }

      ss << "Filter on " << quantitiesNames[fil.on_what] << " : " <<  min_filter[fil.on_what] << " -- " << max_filter[fil.on_what];
      ss << std::endl;
    }
  }
  message(pdata,ss.str());
}

long long howLongIsInputFile(std::string fileName){
  std::ifstream file( fileName.c_str(), std::ios::binary | std::ios::ate);
  long long length = file.tellg();
  file.close();
  return length;
}

void swap_endian_float_array(float* in_f, int n)
{
  int i;
  union {int irep; float frep; char arr[4];}x;
  char buff;
  for(i=0;i<n;i++)
  {
    x.frep=in_f[i];
    buff=x.arr[0];
    x.arr[0]=x.arr[3];
    x.arr[3]=buff;
    buff=x.arr[1];
    x.arr[1]=x.arr[2];
    x.arr[2]=buff;
    in_f[i]=x.frep;
  }
}

void read_next_extremes(MPI_File myFile,long long numreader){
  char* buffer = new char[numreader*sizeof(float)*NUM_COMPONENTS];

  MPI_Status status;
  if (numreader < 0)
    numreader = 0;
  MPI_File_read_all(myFile, buffer, numreader*NUM_COMPONENTS, MPI_FLOAT, &status );

  if(numreader == 0)
    return;

  if(flag_swap){
    swap_endian_float_array((float*)buffer,NUM_COMPONENTS*numreader);
  }

  float* fbuf = (float*)buffer;
  float components[NUM_QUANTITIES];

  for(long long i = 0; i < numreader; i++){
    components[0]=fbuf[NUM_COMPONENTS*i+0];//x
    components[1]=fbuf[NUM_COMPONENTS*i+1];//y
    components[2]=fbuf[NUM_COMPONENTS*i+2];//z
    components[3]=fbuf[NUM_COMPONENTS*i+3];//px
    components[4]=fbuf[NUM_COMPONENTS*i+4];//py
    components[5]=fbuf[NUM_COMPONENTS*i+5];//pz
    components[6]=sqrt(components[3]*components[3]+components[4]*components[4]+components[5]*components[5]);//ptot
    components[7]=mass*(sqrt(1.0+components[6]*components[6])-1);//ktot
    components[8]=atan2(components[4],components[3])/M_PI*180;

    for(int j = 0; j < NUM_QUANTITIES; j++){
      if(components[j]>maxcomponents[j]) maxcomponents[j]=components[j];
      if(components[j]<mincomponents[j]) mincomponents[j]=components[j];
    }
  }


  delete[] buffer;
}

void read_next_plot(MPI_File myFile, long long numreader, double* plotData){
  char* buffer = new char[numreader*sizeof(float)*NUM_COMPONENTS];

  MPI_Status status;
  if (numreader < 0)
    numreader = 0;
  MPI_File_read_all(myFile, buffer, numreader*NUM_COMPONENTS, MPI_FLOAT, &status );

  if(numreader == 0)
    return;

  if(flag_swap){
    swap_endian_float_array((float*)buffer,NUM_COMPONENTS*numreader);
  }

  float* fbuf = (float*)buffer;
  float components[NUM_QUANTITIES];
  float weight;

  long long ibin,jbin,kbin;

  double first_size = first_max-first_min;
  double second_size = second_max-second_min;
  double third_size = third_max-third_min;

  if(flag_1D){
    for(long long i = 0; i < numreader; i++){
      components[0]=fbuf[NUM_COMPONENTS*i+0];//x
      components[1]=fbuf[NUM_COMPONENTS*i+1];//y
      components[2]=fbuf[NUM_COMPONENTS*i+2];//z
      components[3]=fbuf[NUM_COMPONENTS*i+3];//px
      components[4]=fbuf[NUM_COMPONENTS*i+4];//py
      components[5]=fbuf[NUM_COMPONENTS*i+5];//pz
      components[6]=sqrt(components[3]*components[3]+components[4]*components[4]+components[5]*components[5]);//ptot
      components[7]=mass*(sqrt(1.0+components[6]*components[6])-1);//ktot
      components[8]=atan2(components[4],components[3])/M_PI*180;
      weight = fbuf[7*i+6];

      if(flag_with_filters){
        for(int icomp=0; icomp<NUM_QUANTITIES; icomp++){
          if(filter_flags[icomp]&&(components[icomp]<min_filter[icomp] || components[icomp]>max_filter[icomp])){
            weight = 0;
          }
        }

      }



      kbin=0;
      jbin=0;
      ibin = (first_bins-1)*(components[what_first]-first_min)/first_size;
      if (ibin >= 0 && ibin < first_bins)
        plotData[ibin+jbin*first_bins+kbin*first_bins*second_bins] += weight;
    }
  }
  else if(flag_2D){
    for(long long i = 0; i < numreader; i++){
      components[0]=fbuf[NUM_COMPONENTS*i+0];//x
      components[1]=fbuf[NUM_COMPONENTS*i+1];//y
      components[2]=fbuf[NUM_COMPONENTS*i+2];//z
      components[3]=fbuf[NUM_COMPONENTS*i+3];//px
      components[4]=fbuf[NUM_COMPONENTS*i+4];//py
      components[5]=fbuf[NUM_COMPONENTS*i+5];//pz
      components[6]=sqrt(components[3]*components[3]+components[4]*components[4]+components[5]*components[5]);//ptot
      components[7]=mass*(sqrt(1.0+components[6]*components[6])-1);//ktot
      components[8]=atan2(components[4],components[3])/M_PI*180;
      weight = fbuf[7*i+6];


      if(flag_with_filters){
        for(int icomp=0; icomp<NUM_QUANTITIES; icomp++){
          if(filter_flags[icomp]&&(components[icomp]<min_filter[icomp] || components[icomp]>max_filter[icomp])){
            weight = 0;
          }
        }
      }

      kbin=0;
      jbin=(second_bins-1)*(components[what_second]-second_min)/second_size;
      ibin = (first_bins-1)*(components[what_first]-first_min)/first_size;
      if (ibin >= 0 && ibin < first_bins && jbin>=0 && jbin < second_bins)
        plotData[ibin+jbin*first_bins+kbin*first_bins*second_bins] += weight;
    }
  }
  else{
    for(long long i = 0; i < numreader; i++){
      components[0]=fbuf[NUM_COMPONENTS*i+0];//x
      components[1]=fbuf[NUM_COMPONENTS*i+1];//y
      components[2]=fbuf[NUM_COMPONENTS*i+2];//z
      components[3]=fbuf[NUM_COMPONENTS*i+3];//px
      components[4]=fbuf[NUM_COMPONENTS*i+4];//py
      components[5]=fbuf[NUM_COMPONENTS*i+5];//pz
      components[6]=sqrt(components[3]*components[3]+components[4]*components[4]+components[5]*components[5]);//ptot
      components[7]=mass*(sqrt(1.0+components[6]*components[6])-1);//ktot
      components[8]=atan2(components[4],components[3])/M_PI*180;
      weight = fbuf[7*i+6];


      if(flag_with_filters){
        for(int icomp=0; icomp<NUM_QUANTITIES; icomp++){
          if(filter_flags[icomp]&&(components[icomp]<min_filter[icomp] || components[icomp]>max_filter[icomp])){
            weight = 0;
          }
        }
      }

      kbin=(long long)(third_bins-1)*(components[what_third]-third_min)/third_size;
      jbin=(long long)(second_bins-1)*(components[what_second]-second_min)/second_size;
      ibin =(long long)(first_bins-1)*(components[what_first]-first_min)/first_size;
      if (ibin >= 0 && ibin < first_bins && jbin>=0 && jbin < second_bins && kbin >= 0 && kbin < third_bins)
        plotData[ibin+jbin*first_bins+kbin*first_bins*second_bins] += weight;
    }
  }
  delete[] buffer;
}

int howManyFilesExist(std::string strippedFileName){
  const int numZeroes = 5;
  int counter = 0;
  int fID = 0;
  bool hMFEflag = true;

  while(hMFEflag){ 
    std::ifstream infile(composeFileName(strippedFileName, fID));
    if(infile.good()){
      counter++;
      fID++;
      infile.close();
    }
    else{
      hMFEflag=false;
    }
  }
  return counter;
}


void message(parallelData pdata, std::string msg){
  if (pdata.myRank == 0)
    std::cout << msg << std::endl;
  else
    return;
}

void errorMessage(parallelData pdata, std::string msg){
  if (pdata.myRank == 0){
    std::cout << "ERROR: "  << msg << std::endl;
    std::cout.flush();
  }
  MPI_Barrier(pdata.comm);
  MPI_Finalize();
  exit(1);
}

std::string composeFileName(std::string strippedFileName, int fileId){
  const int numZeroes = 5;
  std::stringstream ss;
  ss << strippedFileName <<"."<< std::setfill('0') << std::setw(numZeroes) << fileId;

  return ss.str();
}

long long int calcParticlesToRead(parallelData pdata, int particleTotalNumber){
  long long numPart = particleTotalNumber/pdata.nProc;
  long long rem = particleTotalNumber%pdata.nProc;

  if(pdata.myRank < rem)
    numPart++;

  return numPart;
}


